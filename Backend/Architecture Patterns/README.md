# Architecture Patterns

소프트웨어 아키텍처의 이해와 다양한 아키텍처 패턴들



참고자료

- 박성훈 : 자바 기반의 마이크로서비스 이해와 아키텍처 구축하기
- IBM - 클라우드 컴퓨팅 알아보기
  - [링크](https://www.ibm.com/kr-ko/cloud/learn)



## 1. Software Architecture



### 1.1. 소프트웨어 아키텍처란?



정의

- 소프트웨어를 구성하는 **요소와 요소 간의 관계**를 정의한 청사진
  - 포함 관계, 호출 관계 등을 표현함



역할

- 프로그램이 안정적으로 운영되기 위한 **전체적인 뼈대**
  - 구성 요소 간의 역할 관계가 명확하고 효율적으로 구성되어야 함
- 소프트웨어 구성 전체를 조망하고 이해하는 데 도움을 줌
  - 소통의 도구 역할 : 이해관계자들이 기술 구조를 논의할 수 있도록 함
  - 모두가 이해할 수 있는 언어와 수준으로 작성되어야 함 : **표준화 모델링 언어**(UML 등)로 작성 필요



View

- 아키텍처를 표현하고 접근하는 관점
  - 시스템 복잡도가 증가하며 **아키텍처를 잘 표현하는 것이 중요**해짐
- 4+1뷰
  - ![4+1](https://itwiki.kr/images/d/d9/4%2B1%EB%B7%B0.png)
  - 논리적 뷰 : 구성 요소들의 관계 구조
  - 구현 뷰 : 실제 구현된 측면에서 소프트웨어의 구성과 구조
  - 프로세스 뷰 : 소프트웨어 간의 동적 흐름과 동시성 처리(스레드/프로세스)
  - 배치 뷰 : 시스템에서의 소프트웨어의 배치
  - 유스케이스 뷰 : 시스템의 사용 사례



소프트웨어 아키텍처 스타일

- 스타일이란?
  - **특정 제약 조건에서** 아키텍처의 방향과 접근 방법
    - 스타일의 사전적 의미 : "어떠한 상황"에 잘 어울릴 수 있는 방식이나 형태
- 스타일 vs 패턴
  - 스타일
    - 상황을 해결할 수 있는 접근 방법을 제시함
    - 정답을 제시해 주지는 않음
    - monolith, microservice 등
  - 패턴
    - 시스템의 문제점이나 해결해야 할 문제의 구체적인 해결 방안을 제시
    - Peer to Peer, Event-Bus 등



## 2. Monolithic Apps



![monolithic](https://gblobscdn.gitbook.com/assets%2F-Lej4tgjCgS0Wyj6JGe2%2F-Lf3aFiJ5iI8PxEdUh03%2F-Lf3aShjT-V66QCuldqr%2Fmsa1.PNG?alt=media)



모놀리스 아키텍처란?

- 모든 업무 로직이 하나의 애플리케이션 형태로 패키지되어 서비스됨
  - 예) 위 그림에서는 톰캣 서버에서 작동하는 파일 하나에 모든 컴포넌트가 들어있음
  - 전통적인 웹 시스템 개발 스타일임
- 애플리케이션은 **한 곳에 모여있는 데이터**를 사용하고 참조함
  - **데이터 처리 반응 속도**가 중요



모놀리스 아키텍처의 구성

- 데이터 조회에 대한 부하나 처리에서 생길 수 있는 문제에 대비한 구성
  - 로드 밸런서
  - 2중화, 3중화
  - 백업 및 복구 방안



모놀리스 아키텍처의 문제점

- 규모가 큰 애플리케이션에서는 빌드 및 배포 시간, 서버의 기동 시간이 **오래걸림**
- **협업이 어려움** :  한 두 사람의 실수는 전체 시스템의 빌드 실패를 유발
- 특정 컴포넌트나 모듈에서의 성능 문제나 장애가 다른 컴포넌트에까지 영향을 줌
  - **결합도가 높기** 때문
  - 시스템 컴포넌트들이 서로 로컬 콜(Call-by-Reference) 기반으로 타이트하게 연결됨
- 업데이트와 재배포에 불리함
  - 특정 컴포넌트 수정 시 전체 애플리케이션을 재컴파일해서 전체를 재배포해야 함 
  - 컴포넌트별로 기능 / 비기능적 특성에 맞춰서 다른 기술을 도입하고자 할때 유연하지 않음



## 3. SOA

> Service Oriented Architecture



서비스지향 아키텍처란?

- 업무 처리 단위를 각각의 서비스로 반영하여 **서비스 중심으로 설계**하는 아키텍처 스타일
  - 서비스 중심의 설계라는 점에서 마이크로서비스 아키텍처와 비슷함
  - 기능 중심의 모듈 재사용보다 상위 수준인 **서비스 수준에서의 재사용성**에 초점을 맞춤
- SOA에서는 반복적인 비즈니스 동작들을 논리적이며 독립적인 형태로 구분지어 분리해 놓음
  - 비즈니스로직 컴포넌트와 데이터관리 컴포넌트를 하나의 단일 서비스화 함



마이크로 서비스와의 차이점

- 서비스의 상대적 크기와 관심사
  - SOA는 비즈니스 측면에서의 서비스 재사용성을 강조
    - 애초에 엔터프라이즈 시스템을 중심으로 고안된 아키텍처임
  - 마이크로서비스는 한 가지 작은 서비스에 집중하기를 강조
- 오너십
  - 마이크로서비스는 각 서비스를 하나의 독립된 작은 팀에서 관리함
  - SOA는 비즈니스 흐름과 관련된 서비스를 **중앙 미들웨어**에 탑재하고, 팀 간의 협업이 필요함
    - 필요에 따라 공유된 서비스를 연결 및 조합하여 새로운 서비스를 만들어 냄
- 서비스 공유 정도
  - 마이크로서비스는 서비스 공유의 최소화를 지향함
    - 결합도를 낮추어 변화에 능동적으로 대응하기 위한 민첩성에 초점을 둠
  - SOA는 되도록 많은 서비스의 공유를 지향함
    - 재사용을 높여 비용을 절감하고 품질을 높이는 데 초점을 둠
- 기술 구조
  - 마이크로서비스는 REST API를 사용
    - 구현이 쉽고, 결합도가 낮아 서비스 제공자의 인터페이스에 대한 변경 영향이 발생하지 않음
  - SOA는 공통의 서비스를 ESB에 모아 제공함
    - 공유한 서비스의 명세가 바뀌면 모든 프로그램을 바꿔야하기 때문에 결합도가 높음



서비스지향 아키텍처의 특징

- 서비스 계약
  - 서비스와 서비스 소비자 간의 계약 : 약속한 기능의 수행과 계약 규칙의 준수
  - 계약은 여러 개의 버전을 가짐 : 문제 대응이나 개선
- 서비스 가용성
  - **서비스 라우팅** : 서비스 응답 지연이 발생할 경우 다른 서비스로 요청 경로를 변경해 줌
    - 하드웨어 장비를 이용한 구현 : L4/L7
    - 소프트웨어적 기능으로 구현 : circuit breaker
- 보안
  - 호출 권한에 대한 제어권을 서비스 자체에 넘김
    - 서비스 간 인증 및 권한 확인 없이 바로 호출하면 보안상 문제가 되기 때문
- 트랜잭션
  - SOA에서는 읽기 전용 데이터와 쓰기 데이터 저장소를 분리하도록 권고함
  - 쓰인 데이터를 읽기 위해서 데이터의 이동이 필요 : 일관성, 동기화 이슈 발생
  - **BASE 트랜잭션**의 도입
    - Basically Available Soft State Eventual Consistency : 클라우드의 핵심 개념
    - Basically Available : optimistic locking, queue
    - Soft State : 외부 전달 데이터로 인해서 상태가 갱신되는 것 - 한 노드가 다른 노드의 데이터를 갱신함
    - Eventual Consistency : 두 노드 간 일시적인 일관성 문제가 있어도 결국엔 데이터가 같아진다는 개념
- 서비스 관리
  - 서비스를 상황에 따라 동적으로 증가시키고, 오류 상황에서도 지속 가능하도록 관리함
    - 서비스의 오류를 감지하여 다른 서비스로 요청 흐름을 변경할 수 있음
  - 서비스의 상태는 항상 실시간으로 관리되고 시각화될 수 있음



SOA의 기술 구조

- ESB(Enterprise System Bus)
  - 비즈니스 내에서 서비스, 애플리케이션, 자원을 연결하고 통합하는 **미들웨어**
  - 물리적 컴퓨터 버스와 유사한 기능을 "추상적으로" 제공하며 서비스 간 접점의 수를 줄여줌
    - 데이터 모델의 변환, 심층 연결, 라우팅 및 잠재적으로 여러 요청의 구성을 수행
    - 애플리케이션에서 재사용할 수 있도록 **단일 서비스 인터페이스**로 이를 사용할 수 있도록 함
    - 레코드의 레거시 시스템으로부터 필요한 기능을 생성할 때 SOAP를 사용하기 위한 변환과 통합을 수행해 줌
- UDDI(Universal Description, Discovery and Integration)
  - 통합된 서비스들을 등록하는 서비스 저장소
- WSDL(Web Services Description Language)
  - UDDI에 공유한 서비스의 명세가 담겨 있는 명세서
  - 이 명세서를 참고로 하여 클라이언트는 stub 클래스를 생성, 서버와 SOAP를 이용해 통신함
- SOAP(Simple Object Access Protocol)
  - HTTP등을 통해 **XML 기반 메시지**를 교환하는 프로토콜
- stub 클래스
  - 로컬에서 서버 객체의 메서드를 호출하려고 할 경우, 해당 메서드를 추상적으로 나타내 줌
  - 원격적으로 부를 수 있는 메서드를 공개하는 인터페이스의 형태로 서버에 저장되어 있음



SOA의 문제점

- 조직 구조가 SOA를 제대로 적용할 수 있도록 변화하지 못했기 때문에 도입에 실패했음
  - SOA 개념이 등장한 것이 90년대 초반으로 대부분 기업의 조직 문화가 따라가지 못했음
- ESB 중앙집중형 구조에 따른 **기능의 비대화**
  - 유지, 업데이트, 확장이 어려워짐
  - 통합 볼륨이 증가하면서 ESB 서버에 대한 고가용성 및 장애 복구를 구현하는 데 비용이 많이 소요됨



## 4. MicroServices



### 4.1. 마이크로서비스 아키텍처



마이크로 서비스란?

- 하나의 큰 어플리케이션을 작은 단위로 나누어 서비스하는 것
- SOA를 대용량 웹 서비스 개발에 맞게 경량화, 대규모 개발팀의 조직 구조에 맞도록 변형함



마이크로서비스 아키텍처란?

- 마이크로서비스가 구동되도록 시스템 및 소프트웨어의 구성과 요소 간의 관계를 정의한 아키텍처
- 애플리케이션의 분할 뿐만 아니라 **데이터도 분리하여 독립된 환경으로 구성**함
  - 서비스 별로 DB를 갖고, 배포도 로드밸런서에 의해 독립적으로 수행됨
  - 어플리케이션을 보다 빨리 개발하고 성능을 지속적으로 높일 수 있음



마이크로서비스 도입의 배경

- 데이터를 바라보는 시각의 변화
  - 비정형화된 데이터의 비중이 갈수록 늘어남 : RDBMS로는 부족하여 NoSQL이 도입된 바 있음
  - 모놀리스 아키텍처에서 하듯이 하나의 데이터베이스로 관리하기보다 도메인 별로 관리할 필요성 증대
- 각 서비스별로 정말 필요한 비즈니스 로직만 남겨야 함
  - SOA에서는 공통 또는 특정 결과를 처리하기 위해 단일 서비스화
  - 마이크로서비스에서는 중복되어 재사용할 수 있게 서비스를 하나의 도메인 기준으로 나눔



마이크로 서비스의 기술 구조

- API Gateway와 서비스 메쉬를 이용해 통신함
  - ![API Gateway](https://gblobscdn.gitbook.com/assets%2F-Lej4tgjCgS0Wyj6JGe2%2F-Lf3aFiJ5iI8PxEdUh03%2F-Lf3aSiSQZAMVnFrSo4n%2Fmsa7.PNG?alt=media)
  - 하나의 ESB를 다수의 마이크로서비스 컴포넌트로 나누어 서비스 간 통신을 처리
    - 수많은 서비스 간 통신 기능을 구현하는 것은 대단히 복잡하기 때문
  - API Gateway가 인증, 로깅 등 공통 기능을 처리해 **비즈니스 로직에만 집중**할 수 있게함



마이크로서비스의 단점



## 5. CQRS and Event Sourcing



## 6. Serverless

