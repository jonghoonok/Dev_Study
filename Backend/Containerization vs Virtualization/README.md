# Containerization vs Virtualization

헷갈리기 쉬운 컨테이너와 가상화 개념 정리



## 0. 목차



- [1. 컨테이너](#1-컨테이너)
  * [1.1. 리눅스 컨테이너](#11-리눅스-컨테이너)
  * [1.2. Docker](#12-docker)
  * [1.3. LXC](#13-lxc)
- [2. 가상화](#2-가상화)



## 1. 컨테이너



컨테이너란?

- 컨테이너 엔진을 통해 **가상의 격리된 공간**을 생성하는 기술
  - 호스트 OS의 자원을 공유하지만 **프로세스 간의 격리**를 통해서 가상 공간에 독립성을 부여
    - 별도의 IP 어드레스를 할당하여 프로세스 별로 액세스할 수 있음
    - 각 어플리케이션이 독립된 공간에서 독립된 역할을 수행할 수 있게 함



컨테이너의 활용

- 여러가지 **실행환경을 통채로 백업** 가능
  - 실무에 많이 사용됨
  - 복잡한 실행환경에서 작성된 프로그램은 Docker **환경설정+프로그램을 한번에 배포**
  - 프로그램 업데이트 -> Docker 이미지 작성 -> Jenkins로 배치잡 생성/실행



### 1.1. 리눅스 컨테이너



리눅스 컨테이너 기술이란?

- 리눅스에서 기본적으로 제공하는 컨테이너 기술
  - `chroot` 명령어를 이용하여 OS레벨에서 별도로 분리된 실행환경을 만들 수 있음
  - 해당 공간을 이용해 리눅스를 처음 설치했을 때와 같은 실행환경을 만들어 줌
  - 리눅스 설치 필요 : macOS나 Windows에서는 가상머신 필요함
- 네임 스페이스와 컨트롤그룹이라는 커널 기능을 사용하여 격리된 공간을 관리함



네임 스페이스

- 6가지 네임스페이스를 활용하여 **컨테이너 별 공간에 고유의 이름을 붙임**
- PID : Process ID
  - 각 프로세스에 할당된 고유한 ID
- NET : Network
  - 네트워크 디바이스, IP, 포트 번호, IP 테이블 등
- MNT : Mount
  - 컴퓨터 시스템에 접속되어 있는 디바이스 정보를 OS에 인식하게 함
- UID : User ID
  - 네임스페이스별로 user ID, group ID를 할당함
- UTS 
  - 네임스페이스별로 호스트명과 도메인 명을 독자적으로 가짐
- IPC : Inter Process Communication
  - 프로세스 간 통신 객체를 네임스페이스별로 할당
  - **다른 네임스페이스의 프로세스와 통신 불가**



컨트롤그룹

- 물리적인 **하드웨어의 리소스를 프로세스 그룹 단위로 제어**하는 커널 기능
  - 리소스 : CPU, 메모리, I/O, 네트워크, 디바이스 노드 등
  - 컨테이너의 재기동 없이 리소스를 할당할 수 있게 해줌



### 1.2. Docker

[오라클 : 도커란 무엇입니까?](https://www.oracle.com/kr/cloud-native/container-registry/what-is-docker/)



도커란?

- 리눅스의 어플리케이션들을 프로세스 격리 기술을 사용해 컨테이너로 실행/관리하는 오픈소스 프로젝트
- 소프트웨어의 **실행에 필요한 모든 것**을 포함하는 완전한 파일 시스템 안에 감쌈
  - 코드, 런타임, 시스템 도구, 시스템 라이브러리 등 서버에 설치되는 모든 것을 포함
  - 실행 중인 **환경에 관계 없이 언제나 동일하게 실행**될 것을 보증함
  - "도커는 응용 프로그램과 그 의존성을 가상 컨테이너에 담을 수 있는 도구"



도커 이미지

- 도커 엔진에서 사용하는 기본 단위
- **베이스 이미지** 위에 필요한 라이브러리나 실행 파일 등을 추가하거나 삭제하여 만들 수 있음
  - 도커 이미지를 베이스로 필요한 라이브러리나 파일을 추가-삭제하여 새로운 도커 이미지 생성 가능
- 도커 이미지는 여러 개의 **변경 불가능한 이미지 레이어**로 구성됨
  - 특정 이미지에 액션을 취하면(변경 등) 액션의 재생성을 기술하는 레이어가 추가되어 붙음
    - 이미지를 가볍게 만들어주고 **레이어의 업데이트만 전파**하면 되도록 함
    - 새로운 이미지가 만들어질 때 변경된 사항만을 레이어에 담고, 원래 이미지를 합쳐서 새로운 이미지로 사용자에게 명명
    - 조상 이미지로부터 연속해서 이어지기 때문에 **레이어 단위로 의존성이 있다**고 함
  - 도커 이미지로 컨테이너를 생성할 경우 기존의 레이어들 위에 컨테이너 레이어가 생성됨
    - 이미지 레이어는 삭제 되지 않지만 컨테이너 레이어는 해당 컨테이너가 종료될경우 같이 소멸
    - `docker commit` 을 사용해 기존의 이미지 레이어들과 직접 작성한 컨테이너 레이어를 이용해 새로운 이미지를 생성할 수 있음



도커 컨테이너

- 독립된 공간을 할당하여 **도커 이미지를 실행하는 런타임 객체**
  - 운영체제의 라이브러리와 애플리케이션을 묶어 하나의 런타임 객체를 만들어 냄
- 도커 엔진 위에서 기동되며 가상의 IP와 포트, 이름을 가질 수 있음
  - **각 컨테이너가 하나의 Host**처럼 동작할 수 있게 함
  - 도커 네트워크를 통해 컨테이너 단위로 서비스



도커 레지스트리

- 도커 이미지를 관리할 수 있도록 제공된 저장 공간
  - 레지스트리를 통해 이미지를 다운받고, 공유할 수 있음
  - 예) 레지스트리로부터 이미지를 다운받아 어플리케이션 환경을 구성하고, 소스 저장소에 올린 후 이미지 형태로 빌드한 후 레지스트리를 통해 공유 가능한 상태로 만듦



도커 네트워크	

- 도커 컨테이너 단위로 서비스할 수 있도록 하는 가상의 네트워크 환경
  - **가상의 브리지 docker0**가 외부 네트워크와 각 컨테이너들을 이어 줌
  - 각 컨테이너들에 할당된 가상 IP를 확인하여 연결
- 구성
  - 물리NIC(eth0) - docker0 - 가상NIC(veth) - 각 컨테이너
  - NIC(Network Interface Controller) : 컴퓨터를 네트워크에 연결하는 통신 장치
  - docker daemon이 기동된 후 **각 컨테이너들의 IP는 가상 NIC에 자동으로 할당**됨



### 1.3. LXC





## 2. 가상화



가상화란?

- 컴퓨터에서 컴퓨터 **리소스의 추상화**를 일컫는 광범위한 용어
  - 인데 여기서는 좁은 의미에서 여러 운영체제를 사용하기 위한 가상화로써 다음 정의를 사용함
- **하이퍼바이저**를 이용하여 하나의 시스템에서 **여러 운영체제**를 사용할 수 있게 지원하는 기술
  - 하이퍼바이저는 물리적인 하드웨어 시스템을 논리적인 단위로 나누는 역할을 수행
    - 하드웨어의 자원은 분리되어 가상의 논리적 공간에 할당, 격리된 공간을 제공함
    - 이렇게 격리된 공간을 **가상머신**이라고 함
    - 하이퍼바이저를 VMM(Virtual Machine Manager)이라고도 부름
  - 기업은 서버 가상화를 통해 utilization rate을 10~15%에서 70%이상 수준까지 끌어올릴 수 있음



가상화의 원리

- 하드웨어 위의 하이퍼바이저가 **자신이 하드웨어인 것처럼**(에뮬레이트) 동작
  - OS가 추가로 필요하여 **성능 저하** 존재

![vm](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/images/Chapter2/16_1_Virtual_Models.jpg)



가상화의 종류

- 하이퍼바이저의 위치에 따라 2종류로 분류 가능
- 타입1(native or bare-metal)
  - **Host OS없이** 하드웨어에 하이퍼바이저를 설치하여 사용하는 방식
  - 장단점
    - 장점 : 하드웨어를 직접 제어하기 때문에 오버헤드가 적고 효율적으로 리소스를 사용할 수 있음
    - 단점 : 자체적으로 머신에 대한 관리 기능이 없기 때문에 **관리를 위한 컴퓨터나 콘솔이 필요**함
  - 종류
    - Xen, MS hyper-V, citrix, KVM 등
    - 타입 1의 경우 다시 전가상화와 반가상화로 분류 가능함
- 타입2(hosted)
  - **Host OS위에 하이퍼바이저**가 위치하고, 그 위에서 Guest OS가 구동되는 방식
    - 하이퍼바이저는 일반 프로그램과 같이 호스트 운영 체제에서 실행됨
  - 장단점
    - 장점 : 가상의 하드웨어를 에뮬레이팅하기 때문에 호스트 운영체제에 크게 제약사항이 없음
    - 단점 : OS위에 OS가 얹히는 방식이기 때문에 **오버헤드가 클 수 있음**
  - 가상머신 종류
    - VM Workstation, VMware Server, MS Virtual Sever, Virtual PC, Paralles Workstation 등



전가상화와 반가상화

- 전가상화(Full-Virtualization)
  - 하드웨어를 완전히 가상화 하는 방식 : 하이퍼바이저가 가상머신과 하드웨어의 통역을 수행
    - 하이퍼바이저가 하드웨어인 것처럼 동작: **가상머신의 OS는 자신이 가상 머신인 줄 모름**
    - 하이퍼바이저를 포함한 전체 소프트웨어를 '수정 없이' 가상머신 안에서 실행할 수 있도록 함
  - 장단점
    - 장점 : Guest OS 운영체제의 별다른 수정이 필요 없음
    - 단점 : 하이퍼바이저가 모든 명령을 중재하기 때문에 성능이 **비교적 느림**
- 반가상화(Para-Virtualization)
  - 각 가상머신이 직접 하드웨어와 통신할 수 있음
    - 하이퍼바이저가 **Hyper Call**이라는 API를 제공해 Guest OS가 하드웨어를 직접 제어할 수 있게 함
    - **각 OS는 자신이 가상 머신임을 인지하고**, 수정된 커널이 하이퍼콜을 통해 하드웨어와 통신
  - 하이퍼바이저는 리소스 관리만 수행: 전가상화 대비 빠름
  - 장단점
    - 장점 : 모든 명령을 DOM0를 통해 하이퍼바이저에게 요청하는 전가상화에 비해 성능이 빠름
    - 단점 : Hyper Call 요청을 할 수 있도록 **각 OS의 커널 수정이 필요** - 오픈소스 OS가 아니면 반가상화를 이용하기 쉽지 않음



컨테이너와의 비교

![Containerization vs Virtualization](https://wiki.aquasec.com/download/attachments/2854889/Container_VM_Implementation.png?version=1&modificationDate=1520172703952&api=v2)

![table](./Containerization vs Virtualization.png)



JVM

- 응용프로그램 레벨에서의 가상화: 엄밀하게 가상머신은 아님
- CPU에 의존적이지 않은 bytecode를 생성할 목적으로 만들어짐
  - 생성된 bytecode는 JVM에서 각 운영체제에 맞게 명령을 내림